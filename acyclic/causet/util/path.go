// Copyright 2020 WHTCORPS INC, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package soliton

import (
	"github.com/whtcorpsinc/BerolinaSQL/ast"
	"github.com/whtcorpsinc/BerolinaSQL/perceptron"
	"github.com/whtcorpsinc/milevadb/memex"
	"github.com/whtcorpsinc/milevadb/ekv"
	"github.com/whtcorpsinc/milevadb/stochastikctx"
	"github.com/whtcorpsinc/milevadb/types"
	"github.com/whtcorpsinc/milevadb/soliton/collate"
	"github.com/whtcorpsinc/milevadb/soliton/ranger"
)

// AccessPath indicates the way we access a causet: by using single index, or by using multiple indexes,
// or just by using causet scan.
type AccessPath struct {
	Index          *perceptron.IndexInfo
	FullIdxDefCauss    []*memex.DeferredCauset
	FullIdxDefCausLens []int
	IdxDefCauss        []*memex.DeferredCauset
	IdxDefCausLens     []int
	Ranges         []*ranger.Range
	// CountAfterAccess is the event count after we apply range seek and before we use other filter to filter data.
	CountAfterAccess float64
	// CountAfterIndex is the event count after we apply filters on index and before we apply the causet filters.
	CountAfterIndex float64
	AccessConds     []memex.Expression
	EqCondCount     int
	EqOrInCondCount int
	IndexFilters    []memex.Expression
	BlockFilters    []memex.Expression
	// PartialIndexPaths causetstore all index access paths.
	// If there are extra filters, causetstore them in BlockFilters.
	PartialIndexPaths []*AccessPath

	StoreType ekv.StoreType

	IsDNFCond bool

	// IsTiFlashGlobalRead indicates whether this path is a remote read path for tiflash
	IsTiFlashGlobalRead bool

	// IsIntHandlePath indicates whether this path is causet path.
	IsIntHandlePath    bool
	IsCommonHandlePath bool
	// Forced means this path is generated by `use/force index()`.
	Forced bool
}

// IsBlockPath returns true if it's IntHandlePath or CommonHandlePath.
func (path *AccessPath) IsBlockPath() bool {
	return path.IsIntHandlePath || path.IsCommonHandlePath
}

// SplitCorDefCausAccessCondFromFilters move the necessary filter in the form of index_col = corrlated_col to access conditions.
func (path *AccessPath) SplitCorDefCausAccessCondFromFilters(ctx stochastikctx.Context, eqOrInCount int) (access, remained []memex.Expression) {
	access = make([]memex.Expression, len(path.IdxDefCauss)-eqOrInCount)
	used := make([]bool, len(path.BlockFilters))
	for i := eqOrInCount; i < len(path.IdxDefCauss); i++ {
		matched := false
		for j, filter := range path.BlockFilters {
			if used[j] || !isDefCausEqCorDefCausOrConstant(ctx, filter, path.IdxDefCauss[i]) {
				continue
			}
			matched = true
			access[i-eqOrInCount] = filter
			if path.IdxDefCausLens[i] == types.UnspecifiedLength {
				used[j] = true
			}
			break
		}
		if !matched {
			access = access[:i-eqOrInCount]
			break
		}
	}
	for i, ok := range used {
		if !ok {
			remained = append(remained, path.BlockFilters[i])
		}
	}
	return access, remained
}

// isDefCausEqCorDefCausOrConstant checks if the memex is a eq function that one side is constant or correlated column
// and another is column.
func isDefCausEqCorDefCausOrConstant(ctx stochastikctx.Context, filter memex.Expression, col *memex.DeferredCauset) bool {
	f, ok := filter.(*memex.ScalarFunction)
	if !ok || f.FuncName.L != ast.EQ {
		return false
	}
	_, collation := f.CharsetAndDefCauslation(ctx)
	if c, ok := f.GetArgs()[0].(*memex.DeferredCauset); ok {
		if c.RetType.EvalType() == types.ETString && !collate.CompatibleDefCauslate(collation, c.RetType.DefCauslate) {
			return false
		}
		if _, ok := f.GetArgs()[1].(*memex.Constant); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
		if _, ok := f.GetArgs()[1].(*memex.CorrelatedDeferredCauset); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
	}
	if c, ok := f.GetArgs()[1].(*memex.DeferredCauset); ok {
		if c.RetType.EvalType() == types.ETString && !collate.CompatibleDefCauslate(collation, c.RetType.DefCauslate) {
			return false
		}
		if _, ok := f.GetArgs()[0].(*memex.Constant); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
		if _, ok := f.GetArgs()[0].(*memex.CorrelatedDeferredCauset); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
	}
	return false
}
